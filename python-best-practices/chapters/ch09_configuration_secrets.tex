\chapter{Configuration and Secrets Management}
\section{Chapter Overview}
Mismanaged configuration causes painful outages and leaks.  Treat configuration as data,
with types, validation, and lifecycle controls.

\begin{lstlisting}[caption={Tracking configuration versions},label={lst:config_overview}]
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime


@dataclass(slots=True)
class ConfigVersion:
    """Capture when and why configuration changed."""

    checksum: str
    applied_at: datetime
    change_reason: str
\end{lstlisting}

\section{Typed Configuration Loader}

\begin{lstlisting}[caption={Single entry point for configuration},label={lst:config_loader}]
from __future__ import annotations

from pathlib import Path

from pydantic import BaseSettings, Field


class Settings(BaseSettings):
    database_url: str = Field(..., env="DATABASE_URL")
    log_level: str = Field("INFO", env="LOG_LEVEL")
    feature_flag_path: Path = Field(Path("/etc/app/features.json"), env="FEATURE_FLAG_PATH")

    class Config:
        env_file = ".env"


def load_settings() -> Settings:
    return Settings()
\end{lstlisting}

\section{Secrets Discipline}
Never commit credentials.  Use environment variables, secret stores, or orchestrator
injections.  Run secret scanners like \texttt{trufflehog} in CI to catch mistakes early.

\begin{lstlisting}[caption={Validating secrets at startup},label={lst:config_secrets}]
from __future__ import annotations

import os


def ensure_secret(name: str) -> str:
    """Raise an error if a required secret is absent."""
    if value := os.getenv(name):
        return value
    raise RuntimeError(f"Missing secret: {name}")
\end{lstlisting}

\section{Scenario: Leaked Sandbox Key}
A developer committed sandbox credentials that looked harmless.  A malicious user discovered
the repo and pivoted into production through a little-known trust relationship.  After the
incident, the company adopted automated scanning, rotated all credentials, and required
code reviews for configuration files.

\begin{lstlisting}[caption={Scanning history for secrets},label={lst:config_leak}]
from __future__ import annotations

import subprocess


def scan_history() -> None:
    """Run a lightweight history scan before pushing."""
    subprocess.run(["git", "secrets", "--scan-history"], check=True)
\end{lstlisting}

\section{Summary}
Centralise configuration behind typed loaders, enforce secret hygiene, and document rotation
and validation processes so deployments remain predictable.

\begin{lstlisting}[caption={Summarising config coverage},label={lst:config_summary}]
from __future__ import annotations


def summarize_configs(configs: dict[str, bool]) -> str:
    """Report which services have adopted typed loaders."""
    adopted = [name for name, typed in configs.items() if typed]
    return f"{len(adopted)} services typed config; roll out remaining soon."
\end{lstlisting}

\section*{Exercises}
\begin{enumerate}
  \item Refactor configuration access to funnel through a typed loader similar to
  Listing~\ref{lst:config_loader}.
  \item Add secret scanning to your CI pipeline and test it by committing a fake key.
  \item Document the rotation process for every secret your service relies on.
  \item Implement runtime validation that refuses to start when required environment
  variables are missing.
  \item Design a feature flag strategy (file-based, database, or SaaS) and evaluate trade-offs.
  \item Extend Listing~\ref{lst:config_secrets} so it fetches secrets from your team's vault
  provider with caching and metrics hooks.
\end{enumerate}
