\chapter{Security, Secrets, and Compliance}
\section{Chapter Overview}
Repositories often contain business logic, infrastructure code, and credentials. Treat Git as part of your security boundary: enforce commit signing, scan for secrets, and archive audit evidence before regulators ask.

\section{Signed Commits and Verification}
Signed commits prove provenance and deter impersonation. Require signing on protected branches and bake key setup into onboarding.

\begin{lstlisting}[style=shell,caption={Configuring signed commits end-to-end}]
$ gpg --full-generate-key
$ gpg --list-secret-keys --keyid-format=long
$ git config --global user.signingkey ABCDEF1234567890
$ git config --global commit.gpgsign true
$ gpg --armor --export ABCDEF1234567890 > pubkey.asc
$ gh api user/gpg_keys -X POST -F armored_public_key=@pubkey.asc
\end{lstlisting}

\section{Secret Scanning and Rotation}
Secrets inevitably leak unless you scan locally, in CI, and via GitHub's native detectors. When a secret appears in history, rotate it immediately and document the response.

\begin{lstlisting}[style=shell,caption={Integrating gitleaks locally and in CI}]
$ pre-commit install
$ cat .pre-commit-config.yaml
- repo: https://github.com/gitleaks/gitleaks
  rev: v8.18.2
  hooks:
    - id: gitleaks
$ pre-commit run --all-files
\end{lstlisting}

\section{Compliance Evidence and Audit Trails}
Auditors want immutable records. Export GitHub audit logs, archive CI results, and tag releases tied to regulatory submissions so you can answer "who approved this" without scrambling.

\begin{lstlisting}[style=shell,caption={Archiving audit logs and release metadata}]
$ gh api orgs/org/audit-log --paginate > audit-log-$(date +%F).json
$ gh release view v2.4.0 --json tagName,name,author,createdAt > release-v2.4.0.json
$ aws s3 cp audit-log-$(date +%F).json s3://compliance-bucket/audit/
\end{lstlisting}

\section*{Exercises}
\begin{enumerate}
  \item Enable commit signing enforcement on your main repo and verify it with a test push.
  \item Configure gitleaks (or similar) locally and in CI, then intentionally trigger it with a fake secret.
  \item Rotate one credential discovered in history and document the timeline.
  \item Export a sample audit log and store it in your compliance archive.
  \item Draft a security incident response checklist referencing Git evidence (commits, tags, PRs).
  \item Review ownership for every secret used in CI/CD and fill any rotation gaps.
  \item Evaluate whether your repositories need GitHub Advanced Security features and budget accordingly.
\end{enumerate}

